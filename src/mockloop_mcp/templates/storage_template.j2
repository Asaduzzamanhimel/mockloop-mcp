{# Jinja2 template for storage/persistence functionality #}
import json
import os
import time
import threading
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Union

# Configure path for persistent storage
STORAGE_DIR = Path("mock_data")

# Ensure the storage directory exists
STORAGE_DIR.mkdir(exist_ok=True)

# Mutex for thread-safe file operations
file_mutex = threading.Lock()

class MockStorage:
    """
    A simple storage utility class that provides persistence for mock API data.
    This allows mock APIs to maintain state between requests, simulating a database.
    Data is stored in JSON files in the mock_data directory.
    """
    
    def __init__(self, collection: str):
        """
        Initialize the storage for a specific collection.
        
        Args:
            collection: The name of the collection/entity type (e.g., "users", "products")
        """
        self.collection = collection
        self.file_path = STORAGE_DIR / f"{collection}.json"
        self._ensure_collection_exists()
    
    def _ensure_collection_exists(self) -> None:
        """Ensure the collection file exists with valid JSON structure."""
        if not self.file_path.exists():
            with file_mutex:
                with open(self.file_path, "w") as f:
                    json.dump({"items": [], "last_updated": time.time()}, f)
    
    def _read_collection(self) -> Dict[str, Any]:
        """Read the entire collection from disk."""
        with file_mutex:
            try:
                with open(self.file_path, "r") as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                # If file is corrupted or missing, initialize it
                data = {"items": [], "last_updated": time.time()}
                with open(self.file_path, "w") as f:
                    json.dump(data, f)
                return data
    
    def _write_collection(self, data: Dict[str, Any]) -> None:
        """Write the entire collection to disk."""
        with file_mutex:
            # Update the last_updated timestamp
            data["last_updated"] = time.time()
            with open(self.file_path, "w") as f:
                json.dump(data, f, indent=2)
    
    def get_all(self) -> List[Dict[str, Any]]:
        """
        Get all items in the collection.
        
        Returns:
            List of all items
        """
        data = self._read_collection()
        return data["items"]
    
    def get_by_id(self, item_id: str) -> Optional[Dict[str, Any]]:
        """
        Get an item by its ID.
        
        Args:
            item_id: The ID of the item to retrieve
        
        Returns:
            The item if found, None otherwise
        """
        items = self.get_all()
        for item in items:
            if item.get("id") == item_id:
                return item
        return None
    
    def query(self, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Query items with simple filters.
        
        Args:
            filters: Dictionary of field-value pairs to match
        
        Returns:
            List of items matching all filters
        """
        items = self.get_all()
        results = []
        
        for item in items:
            matches = True
            for key, value in filters.items():
                if key not in item or item[key] != value:
                    matches = False
                    break
            
            if matches:
                results.append(item)
        
        return results
    
    def create(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a new item in the collection.
        
        Args:
            item: The item to create
        
        Returns:
            The created item with assigned ID
        """
        data = self._read_collection()
        
        # Generate an ID if none is provided
        if "id" not in item:
            # Simple ID generation - timestamp + count
            item["id"] = f"{int(time.time())}_{len(data['items']) + 1}"
        
        # Add created_at timestamp if not present
        if "created_at" not in item:
            item["created_at"] = time.time()
        
        # Add the item to the collection
        data["items"].append(item)
        self._write_collection(data)
        
        return item
    
    def update(self, item_id: str, updates: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update an existing item by ID.
        
        Args:
            item_id: ID of the item to update
            updates: Dictionary of fields to update
        
        Returns:
            The updated item if found, None otherwise
        """
        data = self._read_collection()
        
        for i, item in enumerate(data["items"]):
            if item.get("id") == item_id:
                # Update the item
                data["items"][i] = {**item, **updates, "updated_at": time.time()}
                self._write_collection(data)
                return data["items"][i]
        
        return None
    
    def delete(self, item_id: str) -> bool:
        """
        Delete an item by ID.
        
        Args:
            item_id: ID of the item to delete
        
        Returns:
            True if the item was deleted, False if not found
        """
        data = self._read_collection()
        
        initial_count = len(data["items"])
        data["items"] = [item for item in data["items"] if item.get("id") != item_id]
        
        if len(data["items"]) < initial_count:
            self._write_collection(data)
            return True
        
        return False
    
    def delete_all(self) -> int:
        """
        Delete all items in the collection.
        
        Returns:
            Number of items deleted
        """
        data = self._read_collection()
        count = len(data["items"])
        data["items"] = []
        self._write_collection(data)
        return count
    
    def count(self) -> int:
        """
        Count items in the collection.
        
        Returns:
            Number of items in the collection
        """
        data = self._read_collection()
        return len(data["items"])
    
    def exists(self, item_id: str) -> bool:
        """
        Check if an item exists by ID.
        
        Args:
            item_id: ID to check
        
        Returns:
            True if the item exists, False otherwise
        """
        return self.get_by_id(item_id) is not None
    
    def get_last_updated(self) -> float:
        """
        Get the timestamp of the last update to the collection.
        
        Returns:
            Unix timestamp of the last update
        """
        data = self._read_collection()
        return data.get("last_updated", 0)


# Helper function to get a storage instance for a collection
def get_storage(collection: str) -> MockStorage:
    """
    Get a storage instance for the specified collection.
    
    Args:
        collection: Name of the collection
    
    Returns:
        MockStorage instance for the collection
    """
    return MockStorage(collection)
