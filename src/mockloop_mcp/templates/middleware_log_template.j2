{# Jinja2 template for FastAPI logging middleware #}
import logging
import time
import json
import sqlite3
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.types import Message

# Create logs directory if it doesn't exist
import os
from pathlib import Path
logs_dir = Path("logs")
logs_dir.mkdir(exist_ok=True)

# Setup SQLite database for request logs
db_dir = Path("db")
db_dir.mkdir(exist_ok=True)
DB_PATH = db_dir / "request_logs.db"

def init_db():
    conn = sqlite3.connect(str(DB_PATH))
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS request_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT,
        type TEXT,
        method TEXT,
        path TEXT,
        status_code INTEGER,
        process_time_ms INTEGER,
        client_host TEXT,
        client_port TEXT,
        headers TEXT,
        query_params TEXT,
        request_body TEXT,
        response_body TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    conn.commit()
    conn.close()

# Initialize database
init_db()

# Configure logging to both file and console
logger = logging.getLogger("mock_api_logger")
logger.setLevel(logging.INFO)

# Add console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

# Add file handler with daily rotation
from datetime import datetime
log_file = logs_dir / f"requests_{datetime.now().strftime('%Y-%m-%d')}.log"
file_handler = logging.FileHandler(log_file)
file_handler.setLevel(logging.INFO)
file_formatter = logging.Formatter('%(message)s')  # Just the message for cleaner JSON parsing
file_handler.setFormatter(file_formatter)
logger.addHandler(file_handler)

# Prevent duplicate logging
logger.propagate = False

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint):
        start_time = time.time()

        # Attempt to read request body without consuming it for the endpoint
        # This is tricky with FastAPI/Starlette's request object model
        # One common approach is to read it and then reconstruct it if necessary
        # For simple JSON, this is often okay. For streaming/form data, it's more complex.
        
        request_body_bytes = await request.body()
        # Store the body so the endpoint can re-read it if necessary
        # Starlette's Request object has a _body attribute that can be set
        # or use a more robust method if issues arise with specific content types
        
        async def receive() -> Message:
            return {"type": "http.request", "body": request_body_bytes, "more_body": False}
        
        # Create a new Request object with the captured body for the endpoint
        # This ensures the endpoint receives the body correctly after we've read it here.
        # However, directly modifying request._receive or creating a new request like this
        # can be complex. A simpler approach for logging might be to log only metadata
        # or use a more advanced APM tool if full body logging becomes problematic.
        # For now, we'll log what we can and note potential complexities.

        request_body_str = ""
        try:
            request_body_str = request_body_bytes.decode('utf-8')
        except UnicodeDecodeError:
            request_body_str = "[binary data]"
        
        request_log_data = {
            "timestamp": time.strftime('%Y-%m-%dT%H:%M:%S%z', time.gmtime(start_time)),
            "type": "request",
            "method": request.method,
            "path": request.url.path,
            "query_params": str(request.query_params),
            "client_host": request.client.host if request.client else "N/A",
            "client_port": request.client.port if request.client else "N/A",
            "headers": dict(request.headers),
            "body": request_body_str, # Consider truncating large bodies
        }
        logger.info(json.dumps(request_log_data))

        # Re-assign the body to the request object so it can be read by the endpoint
        # This is a common pattern but can have edge cases.
        # Starlette's Request object uses a stream for the body.
        # Once read, it's consumed. We need to "reset" it.
        # The `request._receive` mechanism is internal and can change.
        # A more robust way is to pass the body along if the framework supports it,
        # or accept that logging the body here means it might not be available downstream
        # without special handling.
        # For this mock server, we assume endpoints might not need the body if it's simple.
        # If they do, this part needs to be very robust.

        # Create a new scope for the request with the original body
        # This is a more robust way to ensure the body is available for the endpoint
        scope = request.scope
        
        # Create a new receive channel that will provide the body
        async def new_receive():
            return {"type": "http.request", "body": request_body_bytes, "more_body": False}

        # Create a new request object with the new receive channel
        # This is not straightforward as Request objects are not meant to be mutated this way easily.
        # The most reliable way is often to have the endpoint itself log its received body if critical.
        # Or, use a framework feature if available.
        # For now, we log the body as read, and accept limitations.

        response = await call_next(Request(scope, receive=new_receive)) # Pass new request with body

        process_time_ms = int((time.time() - start_time) * 1000)

        response_body_bytes = b""
        async for chunk in response.body_iterator:
            response_body_bytes += chunk
        
        response_body_str = ""
        try:
            response_body_str = response_body_bytes.decode('utf-8')
        except UnicodeDecodeError:
            response_body_str = "[binary data]"

        response_log_data = {
            "timestamp": time.strftime('%Y-%m-%dT%H:%M:%S%z', time.gmtime()),
            "type": "response",
            "method": request.method,
            "path": request.url.path,
            "status_code": response.status_code,
            "process_time_ms": process_time_ms,
            "headers": dict(response.headers),
            "body": response_body_str, # Consider truncating
        }
        logger.info(json.dumps(response_log_data))
        
        # Check if this is an admin request
        is_admin = request.url.path.startswith('/admin')
        
        # DEBUG: Log admin request detection
        print(f"DEBUG MIDDLEWARE: Request path: {request.url.path}")
        print(f"DEBUG MIDDLEWARE: Is admin request: {is_admin}")
        
        # Store request and response in SQLite database
        try:
            conn = sqlite3.connect(str(DB_PATH))
            cursor = conn.cursor()
            
            # First, check if we need to update the schema to add the is_admin column
            cursor.execute("PRAGMA table_info(request_logs)")
            columns = cursor.fetchall()
            column_names = [col[1] for col in columns]
            
            if 'is_admin' not in column_names:
                # Add the is_admin column to the table
                cursor.execute('ALTER TABLE request_logs ADD COLUMN is_admin BOOLEAN DEFAULT 0')
                conn.commit()
                print("DEBUG MIDDLEWARE: Added is_admin column to database")
            
            cursor.execute('''
                INSERT INTO request_logs (
                    timestamp, type, method, path, status_code,
                    process_time_ms, client_host, client_port,
                    headers, query_params, request_body, response_body, is_admin
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                time.strftime('%Y-%m-%dT%H:%M:%S', time.gmtime()),
                "request",
                request.method,
                request.url.path,
                response.status_code,
                process_time_ms,
                request.client.host if request.client else "N/A",
                str(request.client.port) if request.client else "N/A",
                json.dumps(dict(request.headers)),
                str(request.query_params),
                request_body_str,
                response_body_str,
                1 if is_admin else 0
            ))
            conn.commit()
            print(f"DEBUG MIDDLEWARE: Stored request log with is_admin={1 if is_admin else 0}")
            conn.close()
        except Exception as e:
            logger.error(f"Failed to store request log in database: {e}")
            print(f"DEBUG MIDDLEWARE: Database error: {e}")
        
        # Return a new response with the consumed body, as body_iterator consumes it
        return Response(
            content=response_body_bytes,
            status_code=response.status_code,
            headers=dict(response.headers),
            media_type=response.media_type
        )

# In the generated main.py, this middleware will be added to the app:
# from .logging_middleware import LoggingMiddleware # Assuming it's saved as logging_middleware.py
# app.add_middleware(LoggingMiddleware)
